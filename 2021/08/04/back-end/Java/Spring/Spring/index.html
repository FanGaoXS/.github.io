<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Spring简单剖析 | FanGaoXS&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1、Spring概述Spring是什么Spring是一个 开源的 轻量级的 Java SE或Java EE 开发应用框架，其目的是简化企业级应用程序的开发。 Spring框架提供日志记录、性能统计、安全控制、异常处理等面向切面的功能，还提供数据库事务管理：本身有一套简单的JDBC访问实现，同时还提供与第三方数据访问框架的集成，还提供一套web层的框架SpringMVC。 所以Spring框架是超级">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring简单剖析">
<meta property="og:url" content="https://fangaoxs.github.io/2021/08/04/back-end/Java/Spring/Spring/index.html">
<meta property="og:site_name" content="FanGaoXS&#39;s blog">
<meta property="og:description" content="1、Spring概述Spring是什么Spring是一个 开源的 轻量级的 Java SE或Java EE 开发应用框架，其目的是简化企业级应用程序的开发。 Spring框架提供日志记录、性能统计、安全控制、异常处理等面向切面的功能，还提供数据库事务管理：本身有一套简单的JDBC访问实现，同时还提供与第三方数据访问框架的集成，还提供一套web层的框架SpringMVC。 所以Spring框架是超级">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fangaoxs.github.io/2021/08/04/back-end/Java/Spring/Spring/IoC%E5%88%9D%E5%A7%8B%E5%8C%96.png">
<meta property="og:image" content="https://fangaoxs.github.io/2021/08/04/back-end/Java/Spring/Spring/Bean%E7%9A%84%E6%B3%A8%E5%85%A5.png">
<meta property="og:image" content="https://fangaoxs.github.io/2021/08/04/back-end/Java/Spring/Spring/CGLIB%E8%B7%9F%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E6%88%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B3%E7%B3%BB.gif">
<meta property="og:image" content="https://fangaoxs.github.io/2021/08/04/back-end/Java/Spring/Spring/image-20210804142503656.png">
<meta property="og:image" content="https://fangaoxs.github.io/2021/08/04/back-end/Java/Spring/Spring/image-20210804145139577.png">
<meta property="article:published_time" content="2021-08-04T07:30:39.000Z">
<meta property="article:modified_time" content="2024-02-18T08:52:47.319Z">
<meta property="article:author" content="FanGaoXS">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fangaoxs.github.io/2021/08/04/back-end/Java/Spring/Spring/IoC%E5%88%9D%E5%A7%8B%E5%8C%96.png">
  
    <link rel="alternate" href="/atom.xml" title="FanGaoXS's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">FanGaoXS&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fangaoxs.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-back-end/Java/Spring/Spring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/back-end/Java/Spring/Spring/" class="article-date">
  <time class="dt-published" datetime="2021-08-04T07:30:39.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Spring简单剖析
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1、Spring概述"><a href="#1、Spring概述" class="headerlink" title="1、Spring概述"></a>1、Spring概述</h1><h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><p>Spring是一个 <strong>开源的</strong> <strong>轻量级的</strong> Java SE或Java EE 开发应用框架，其目的是简化企业级应用程序的开发。</p>
<p>Spring框架提供<strong>日志记录</strong>、<strong>性能统计</strong>、<strong>安全控制</strong>、<strong>异常处理</strong>等面向切面的功能，还提供<strong>数据库事务管理</strong>：本身有一套简单的<strong>JDBC访问实现</strong>，同时还提供与第三方数据访问框架的集成，还提供一套web层的框架SpringMVC。</p>
<p>所以Spring框架是超级粘合平台，不仅自身提供基础功能，还提供与其他技术或其他框架整合的能力，使得Java SE和Java EE开发都很简单。</p>
<blockquote>
<p><strong>牢记</strong>三个特点：</p>
<p>1、基于AOP的日志记录、性能统计、安全控制等功能</p>
<p>2、数据层，提供JDBC访问和集成第三方ORM框架的能力</p>
<p>3、Web层，提供Spring MVC框架和集成第三方Web框架的能力</p>
</blockquote>
<h2 id="Spring能做什么"><a href="#Spring能做什么" class="headerlink" title="Spring能做什么"></a>Spring能做什么</h2><p>Spring框架能带给我们最多的就是<strong>简化开发</strong>：</p>
<ul>
<li>简化依赖关系。Spring会根据配置文件来创建和组装对象间依赖关系，只需要修改配置文件即可。</li>
<li>低耦合地实现日志记录、性能统计、安全控制。Spring面向切面编程能够帮助开发者实现低耦合的日志记录、性能统计、安全控制。</li>
<li>管理数据库事务。Spring能够帮助开发者提供基础的数据库事务管理。</li>
<li>与第三方数据访问层框架无缝集成。能够与Hibernate、JPA等第三方框架无缝集成，同时自己也提供一套JDBC访问模板。</li>
<li>与第三方Web框架无缝集成。能够与Struts、JSF等第三方框架无缝集成，同时自己也提供一套Spring MVC框架，方便web层搭建。</li>
<li>方便整合技术。能够与Java Mail、缓存等技术无缝整合。</li>
</ul>
<h2 id="Spring的相关概念"><a href="#Spring的相关概念" class="headerlink" title="Spring的相关概念"></a>Spring的相关概念</h2><ul>
<li>应用程序（Application）：即完成所需功能或需求的<strong>成品</strong>，如购物网站、OA系统、xx小程序。</li>
<li>框架（Framework）：是能够完成一定功能的<strong>半成品</strong>，如我们可以在框架的基础上进一步开发购物网站，但是框架本身不一定就是最终成品。大多数时候是框架实现一部分功能，自己本身再实现一部分功能，最终形成应用程序。但是框架大多数时候会规定或者约定了开发应用程序的整体架构，提供了基础功能，简化开发人员的后续开发，使得开发人员更加专注于业务逻辑。</li>
<li>非侵入式设计：无需继承框架提供的类，这样的设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入式设计。非侵入式设计假如在后续想要更换框架则之前写的代码可以复用；侵入式设计则无法复用。</li>
<li>POJO：即Plain Old Java Objects，简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。</li>
<li>容器：日常生活中来理解容器就是盛放东西的器具，从程序设计角度看就是装对象的对象，因为存在放入、拿出的“行为”，所以容器还要管理对象的生命周期。</li>
<li>控制反转：即Inversion of Control，缩写为IoC，它还有一个别名叫依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统开发中由程序代码控制。</li>
<li>Bean：一般指容器管理的对象，在Spring中指IoC容器管理的对象。</li>
</ul>
<h2 id="Spring的优点"><a href="#Spring的优点" class="headerlink" title="Spring的优点"></a>Spring的优点</h2><ul>
<li>非常<strong>轻量级的容器</strong>。以集中的、自动化的方式进行应用程序对象创建和装配，负责对象的创建和装配，管理对象的生命周期，能够组合成复杂的应用程序。IoC容器是非侵入式的，不需要依赖任何特定类。且核心JAR包非常小，Spring3.0.5不到1M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE或Java EE）。</li>
<li>面向切面编程（AOP）。AOP是Aspect Oriented Programming的缩写。提供从另一个角度来考虑程序结构以完善面向对象编程，即可以通过在编译期间、装载期间或运行期间在不修改源代码的情况下为程序动态添加功能的一种技术。</li>
<li>简单的数据库事务管理。Spring支持简单的可插入的事务管理支持。</li>
<li>JDBC抽象及ORM框架支持。Spring本身提供JDBC访问支持，并且还非常方便集成ORM框架，如Hibernate等，还支持使用Spring事务和Spring提供的异常。</li>
<li>灵活的Web层支持。Spring本身提供一套强大的MVC框架，Spring MVC，同时还方便与其他Web层框架集成，比如Struts等。</li>
<li>简化各种技术并且简化集成。简化并提供对Java Mail、任务调度、JMX、JNDI、EJB、Web Service等的集成。</li>
</ul>
<p>Spring框架为开发者简化应用程序的开发，并且还对JDBC、ORM、Web提供良好的支持，并且还对其他很多技术提供良好的整合，使系统结构更优良，性能更好。</p>
<h2 id="如何学好Spring"><a href="#如何学好Spring" class="headerlink" title="如何学好Spring"></a>如何学好Spring</h2><p>Spring的核心是IoC容器，他的所有技术基本都是基于容器来实现的。所以先要透彻理解IoC容器，如何配置和使用他。</p>
<p>理解完IoC容器后再理解AOP，明确概念-&gt;基本配置-&gt;如何使用-&gt;实现原理。接下来就是简单的Spring事务管理了，其实Spring事务管理是通过AOP实现的，所以需要先理解AOP。</p>
<h1 id="2、Spring-IoC核心流程简述"><a href="#2、Spring-IoC核心流程简述" class="headerlink" title="2、Spring IoC核心流程简述"></a>2、Spring IoC核心流程简述</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化的过程主要是读取XML资源，然后解析，最终注册到Bean Factory中：</p>
<p><img src="/2021/08/04/back-end/Java/Spring/Spring/IoC%E5%88%9D%E5%A7%8B%E5%8C%96.png"></p>
<p>完成初始化后，Bean对象就在BeanFactory中等待调用了。</p>
<h2 id="注入依赖"><a href="#注入依赖" class="headerlink" title="注入依赖"></a>注入依赖</h2><p>当初始化完IoC容器后，如果Bean没有设置lazy-init（懒加载）属性的话，那么bean实例的初始化就会在IoC初始化完成后：</p>
<p><img src="/2021/08/04/back-end/Java/Spring/Spring/Bean%E7%9A%84%E6%B3%A8%E5%85%A5.png"></p>
<h1 id="3、Java代理模式的实现"><a href="#3、Java代理模式的实现" class="headerlink" title="3、Java代理模式的实现"></a>3、Java代理模式的实现</h1><p>在聊代理之前需要搞懂为什么需要代理这个东西，它的目的是什么。代理模式是为了在不修改已有代码的前提下，对原来的功能进行增强（做更多处理），比如打印日志，安全控制等。其实不使用代理模式的话也可以实现，但是对代码的入侵性极高，所以使用代理模式几乎可以做到对原有代码没有入侵，并且能够实现想要的功能。</p>
<p>Java代理模式主要有三种：JDK静态代理、JDK动态代理和CGLIB动态代理。其中Spring的AOP的实现中就是利用了JDK动态代理和CGLIB动态代理。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>Java静态代理是代理类和被代理类共同实现同一接口，代理类对被代理类的操作进行增强。</p>
<p>比如：我创建一个学生类，有一个跑方法，我需要代理类对跑进行增强：跑之前操作，跑之后操作。</p>
<p>共同接口StudentInterface.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通学生类（被代理类）Student.java：（有name属性）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">StudentInterface</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; is running &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强学生类（代理类）StudentProxy.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentProxy</span> <span class="keyword">implements</span> <span class="title class_">StudentInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StudentInterface target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentProxy</span><span class="params">(StudentInterface target)</span>&#123;</span><br><span class="line">        <span class="comment">// 在代理类初始化时传入目标类</span></span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; before running &quot;</span>);<span class="comment">//增强</span></span><br><span class="line">        <span class="built_in">this</span>.target.run();<span class="comment">//目标类本身操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot; after running &quot;</span>);<span class="comment">//增强</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试执行Main.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被代理类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">//代理类对象</span></span><br><span class="line">        <span class="type">StudentProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentProxy</span>(student);</span><br><span class="line">        <span class="comment">//代理类执行方法</span></span><br><span class="line">        proxy.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，普通学生类（被代理类）和增强学生类（代理类）都实现了同一接口，并且都实现了<code>run</code>方法，普通类就是很普通的执行了，但是代理类里不仅执行了<code>run</code>方法，还在<code>run</code>方法前后进行了更多的处理（也就是增强）。所以这就是静态代理，在不改变原代码的前提下，使用另一个类对原类进行进一步的增强处理（比如打印日志，安全控制等）。在普通学生类Student的代码中是完全感知不到的，对原代码没有入侵。</p>
<ol>
<li>统一接口</li>
<li>普通类（被代理类）</li>
<li>增强类（代理类）以参数的形式获得目标类，执行普通类中方法再进行增强。</li>
</ol>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java动态代理仍然需要指定一个接口，但是代理类并不需要实现它。主要是利用<strong>Java反射机制</strong>来获取到被代理类执行的方法。</p>
<p>接口StudentInterface.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被代理类Student.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">StudentInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类StudentProxyHandler.java：</p>
<p>和静态代理的类似，都需要获得被代理类对象。不过动态代理需要实现<code>InvocationHandler</code>接口，然后重新<code>invoke()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentProxyHandler</span><span class="params">(Object subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          proxy    代理类对象</span></span><br><span class="line"><span class="comment">          method   被代理类执行的方法</span></span><br><span class="line"><span class="comment">          args     被代理类执行的参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke &quot;</span>+method.getName());</span><br><span class="line">        method.invoke(subject,args);<span class="comment">//执行被代理类的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke &quot;</span>+method.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试执行Main.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 被代理类</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        <span class="comment">// 代理类</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentProxyHandler</span>(student);</span><br><span class="line"></span><br><span class="line">        <span class="type">StudentInterface</span> <span class="variable">studentInterface</span> <span class="operator">=</span> (StudentInterface) Proxy.newProxyInstance(</span><br><span class="line">                student.getClass().getClassLoader(),</span><br><span class="line">                student.getClass().getInterfaces(),</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line">        studentInterface.run();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        print:</span></span><br><span class="line"><span class="comment">            before invoke run</span></span><br><span class="line"><span class="comment">            Jack is running</span></span><br><span class="line"><span class="comment">            after invoke run</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到StudentProxyHandler是实现了InvocationHandler，重写了<code>invoke()</code>方法，invoke方法中的第一个参数proxy是代理类，第二个参数method是被代理类执行的方法，第三个参数args是被代理类执行的参数。动态代理原理就是利用Java反射机制来获得被代理类执行的方法，执行的参数，执行的方法的返回值等。</p>
<ol>
<li>接口</li>
<li>被代理类实现接口</li>
<li>代理类实现InvocationHandler接口，重写invoke方法，并利用好proxy、method、args参数。</li>
</ol>
<blockquote>
<p><strong>区别</strong></p>
<p>动态代理相较于静态代理的区别在于动态代理能够利用反射获取到执行方法各个属性，比如方法名、方法参数、方法返回值等。</p>
</blockquote>
<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>Cglib是一个强大的、高性能的代码生成包，它广泛被许多AOP框架使用，为他们提供方法的拦截。下，下图是我网上找到的一张Cglib与一些框架和语言的关系：</p>
<p><img src="/2021/08/04/back-end/Java/Spring/Spring/CGLIB%E8%B7%9F%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E6%88%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B3%E7%B3%BB.gif"></p>
<ul>
<li>最底层的是字节码Bytecode，字节码是Java为了保证“一次编译、到处运行”而产生的一种虚拟指令格式，例如iload_0、iconst_1、if_icmpne、dup等</li>
<li>位于字节码之上的是ASM，这是一种直接操作字节码的框架，应用ASM需要对Java字节码、Class结构比较熟悉</li>
<li>位于ASM之上的是CGLIB、Groovy、BeanShell，后两种并不是Java体系中的内容而是脚本语言，它们通过ASM框架生成字节码变相执行Java代码，这说明在JVM中执行程序并不一定非要写Java代码—-只要你能生成Java字节码，JVM并不关心字节码的来源，当然通过Java代码生成的JVM字节码是通过编译器直接生成的，算是最“正统”的JVM字节码</li>
<li>位于CGLIB、Groovy、BeanShell之上的就是Hibernate、Spring AOP这些框架了，这一层大家都比较熟悉</li>
<li>最上层的是Applications，即具体应用，一般都是一个Web项目或者本地跑一个程序</li>
</ul>
<h2 id="三种代理方式的区别"><a href="#三种代理方式的区别" class="headerlink" title="三种代理方式的区别"></a>三种代理方式的区别</h2><table>
<thead>
<tr>
<th>代理方式</th>
<th>实现</th>
<th>优点</th>
<th>缺点</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>JDK静态代理</td>
<td>代理类与委托类实现同一接口，并且在代理类中需要硬编码接口</td>
<td>实现简单，容易理解</td>
<td>代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低</td>
<td>好像没啥特点</td>
</tr>
<tr>
<td>JDK动态代理</td>
<td>代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理</td>
<td>不需要硬编码接口，代码复用率高</td>
<td>只能够代理实现了接口的委托类</td>
<td>底层使用反射机制进行方法的调用</td>
</tr>
<tr>
<td>CGLIB动态代理</td>
<td>代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理</td>
<td>可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口</td>
<td>不能对final类以及final方法进行代理</td>
<td>底层将方法全部存入一个数组中，通过数组索引直接进行方法调用</td>
</tr>
</tbody></table>
<h1 id="4、Spring事务概述"><a href="#4、Spring事务概述" class="headerlink" title="4、Spring事务概述"></a>4、Spring事务概述</h1><h2 id="数据库事务概述"><a href="#数据库事务概述" class="headerlink" title="数据库事务概述"></a>数据库事务概述</h2><p><strong>事务：</strong>是一系列操作组成的工作单元。该工作单元内的操作是不可分割的，即要么所有的<strong>操作都做</strong>，要么所有的<strong>操作都不做</strong>。</p>
<p>事务必须满足ACID（原子性、一致性、隔离性、持久性）原则，缺一不可：</p>
<ul>
<li>原子性（Atomicity）：即事务是不可分割的最小单元，事务内的操作要么全做，要么全不做。</li>
<li>一致性（Consistency）：即事务完成前后数据库状态是一致的。</li>
<li>隔离性（Isolation）：并发执行的事务之间是不会相互影响的，一个事务执行的内部不会对其他事务产生影响。（无法避免，所以才会产生事务隔离级别）</li>
<li>持久性（Durability）：事务一旦执行成功，它对数据库的改变是永久的，不会因为断电或者系统故障导致数据不一致或者丢失。</li>
</ul>
<p>实际并发操作可能会出现以下问题：</p>
<ul>
<li>脏读：（A事务读取了B事务还未确定提交的数据，但是B事务回滚了）。A事务读取到了B事务还没提交的数据，最终B事务回滚了，那么A事务就读到了不应该读到的数据。</li>
<li>不可重复读：（读取到了提交的新事务，指更新操作）A事务多次读取数据时不一致，原因是B事务在此期间修改了数据。</li>
<li>幻读：（读取到了提交的新事务，指增删操作）A事务多次读取数据时不一致，原因是B事务在此期间增删了记录。</li>
<li>第一类事务丢失：（回滚丢失）指A事务和B事务同时操作一条数据（A事务比B事务先或同时开始），B事务提交了修改，但是A事务最后回滚了，那么数据最后就会回滚到A事务前，则B事务提交的修改就会丢失。（事务的特性：执行事务前会将数据当前状态“快照”，以便回滚）。</li>
<li>第二类事务丢失：（提交覆盖丢失）指A事务和B事务同时操作一条数据，B事务中途提交了修改，最后提交事务，可是在B事务完成的过程中A事务也进行了修改，最后的结果确实以B事务提交的结果为准，所以A事务的修改就被覆盖了。</li>
</ul>
<p>为了解决以上问题，事务隔离级别由低到高分为Read Uncommited、Read commited、Repeatable read、Serializable。分别是<strong>读未提交、读已提交、可重复读、串行化</strong>。</p>
<ul>
<li>Read Uncommited（读未提交）：A事务能够读到B事务还未提交的数据，可能会<strong>出现脏读</strong>。</li>
<li>Read Commited（读已提交）：A事务只能在B事务提交后才能读，可能会<strong>出现不可重复读</strong>，但是&#x3D;&#x3D;解决了脏读&#x3D;&#x3D;。原因是A事务只能在B事务完成前后才能读，如果B事务发生了修改，那么B事务完成前后的数据肯定不相同，所以数据才会不重复。</li>
<li>Repeatable Read（可重复读）：B事务开启时，A事务不能再修改数据。可能会<strong>出现幻读</strong>，但是&#x3D;&#x3D;解决了不可重复读&#x3D;&#x3D;。原因是B事务开启后，此时A事务即使读到但是无法修改，但是A事务可以读到修改中途的数据。</li>
<li>Serializable（串行化）：所有事务按顺序执行，必须等前一个事务执行完毕后再执行下一个事务，效率较低，但是可以解决以上所有问题。</li>
</ul>
<p>大多数据库默认的隔离级别是Read Commited（读已提交），如Sql Server、Oracle。</p>
<p>MySQL的默认隔离级别是Repeated Read（可重复读）。</p>
<blockquote>
<p>为什么会有事务隔离？</p>
<p>虽然依据事务的隔离性原则来说，事务与事务之间不会相互影响。可是项目实际运行过程中可能会出现很多人一起访问资源的并发情况，所以这个时候必定会出现一些事务与事务之间相互影响的情况，如：脏读、幻读等，针对这些可能出现的情况，就出现了事务的隔离级别，隔离级别越低对两个事务之间就越不干涉，这样效率最高，但是互相影响就越大。</p>
<p>所以需要考虑项目实际运行过程中事务与事务之间能接受的影响程度以及项目运行效率，结合两者来确定隔离级别，以达到效率最大化、事务之间影响最小化。</p>
</blockquote>
<h2 id="事务类型"><a href="#事务类型" class="headerlink" title="事务类型"></a>事务类型</h2><p>Spring支持编程式事务管理和声明式事务管理两种。其中比较推荐使用声明式事务管理的方式。</p>
<h3 id="Spring编程式事务（了解）"><a href="#Spring编程式事务（了解）" class="headerlink" title="Spring编程式事务（了解）"></a>Spring编程式事务（了解）</h3><p>编程式事务管理对代码有侵入性（所以不推荐），使用TransactionTemplate或者使用PlatformTransactionManager，对于编程式事务管理，Spring更推荐使用TransactionTemplate。</p>
<p>需要导入<code>TransactionTemplate</code>然后调用<code>excute()</code>方法，里面包含的就是一整条事务了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transactionOne</span><span class="params">()</span>&#123;</span><br><span class="line">        transactionTemplate.execute(transactionStatus -&gt; &#123;</span><br><span class="line">            userService.selectAllUser();</span><br><span class="line">            userService.deleteOneUser(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>transactionTemplate.execute()</code>的参数是一个<code>TransactionCallback</code>接口，这个接口只有一个抽象方法<code>doInTransaction()</code>。所以可以使用lambda表达式（当参数是一个接口，并且接口中只有一个抽象方法时，可以使用匿名内部类+lambda表达式）。</p>
<p>其中<code>transactionOne()</code>就是一个事务，<code>transactionTemplate.execute()</code>就是开启事务，并且事务里包含两条操作。（其中一个操作出错了整条事务就会回滚）。</p>
<h3 id="Spring声明式事务（熟悉）"><a href="#Spring声明式事务（熟悉）" class="headerlink" title="Spring声明式事务（熟悉）"></a>Spring声明式事务（熟悉）</h3><p>声明式事务管理器是基于AOP的，所以对代码的入侵性较小，这也是Spring所倡导的非侵入式编程方式。</p>
<p>声明式事务管理器有两种开启方式：</p>
<ol>
<li>在XML文件里配置</li>
<li>以注解的方式配置（<code>@Transactional</code>）</li>
</ol>
<p>这里重点讲解以注解的方式，<code>@Transactional</code>注解可以加在类或者方法上，如果加在类上表示该类下的所有方法都交给事务管理器管理，加在方法上则表示该类交给事务管理器管理。</p>
<p>加在类上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transactionOne</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transactionTwo</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加在方法上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transactionOne</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transactionTwo</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时该注解也可以为事务配置隔离级别、事务传播特性、回滚规则、是否只读、事务超时时间等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line">    <span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String <span class="title function_">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String[] label() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">    Isolation <span class="title function_">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">timeoutString</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Spring的默认隔离级别是<code>Isolation.DEFAULT</code>，这个值为-1，代表的是数据库的默认隔离级别，也就是说Spring的默认隔离级别是数据库的默认隔离级别。同样的，Spring有以下隔离级别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Isolation</span> &#123;</span><br><span class="line">    DEFAULT(-<span class="number">1</span>),</span><br><span class="line">    READ_UNCOMMITTED(<span class="number">1</span>), <span class="comment">//读未提交</span></span><br><span class="line">    READ_COMMITTED(<span class="number">2</span>),   <span class="comment">//读已提交</span></span><br><span class="line">    REPEATABLE_READ(<span class="number">4</span>),	 <span class="comment">//可重复读</span></span><br><span class="line">    SERIALIZABLE(<span class="number">8</span>);     <span class="comment">//串行化</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<h3 id="编程式事务和声明式事务的区别"><a href="#编程式事务和声明式事务的区别" class="headerlink" title="编程式事务和声明式事务的区别"></a>编程式事务和声明式事务的区别</h3><p>编程式事务每次都需要单独实现，如果遇到业务量大且复杂的时候，使用编程式事务则会是一场灾难。而声明式事务属于非侵入式，不会影响业务的逻辑实现，只需要在需要的方法或者类上加上注解，或者使用XML的方式配置。</p>
<p>唯一不足的地方就是声明式事务管理的粒度是<strong>方法级别</strong>，而编程式事务管理是可以到<strong>代码块</strong>的，但是可以通过提取方法的方式完成声明式事务管理的配置。</p>
</blockquote>
<h3 id="Spring事务的传播行为"><a href="#Spring事务的传播行为" class="headerlink" title="Spring事务的传播行为"></a>Spring事务的传播行为</h3><h4 id="外围方法和内部方法"><a href="#外围方法和内部方法" class="headerlink" title="外围方法和内部方法"></a>外围方法和内部方法</h4><p>Spring讲事务传播行为前需要了解两个概念，外围方法和内部方法。如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    </span><br><span class="line">    Boolean <span class="title function_">insertOne</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transaction</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionOne</span><span class="params">()</span>&#123;</span><br><span class="line">        Service.insertOne();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Transaction类中，<code>transactionOne()</code>对于<code>Service.insertOne()</code>来说，就是外围方法，而<code>Service.insertOne()</code>里面就是内部方法。内部开启事务管理则是在<code>insertOne()</code>加注解，外围开启事务则是在<code>transactionOne()</code>加注解。</p>
<h4 id="Spring中七种事务传播行为"><a href="#Spring中七种事务传播行为" class="headerlink" title="Spring中七种事务传播行为"></a>Spring中七种事务传播行为</h4><p>参考<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344">Spring事务传播行为详解@JerryTse</a></p>
<table>
<thead>
<tr>
<th>事务传播行为类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<h4 id="PROPAGATION-REQUIRED（Spring默认事务传播行为）"><a href="#PROPAGATION-REQUIRED（Spring默认事务传播行为）" class="headerlink" title="PROPAGATION_REQUIRED（Spring默认事务传播行为）"></a>PROPAGATION_REQUIRED（Spring默认事务传播行为）</h4><p>在<strong>外围方法未开启事务</strong>的情况下<code> PROPAGATION_REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。<strong>外围方法没有开启事务，则内部方法分别开启自己的事务，相互独立互不干扰。</strong></p>
<p>在<strong>外围方法开启事务</strong>的情况下<code>PROPAGATION_REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>PROPAGATION_REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。<strong>如果外围方法开启事务，则内部方法也加入进该事务，统一为同一事务。</strong></p>
<h4 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a>PROPAGATION_REQUIRES_NEW</h4><p>在<strong>外围方法未开启事务</strong>的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。<strong>外围方法没有开启事务，则内部方法分别开启自己的事务，相互独立互不干扰。</strong></p>
<p>在<strong>外围方法开启事务</strong>的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。<strong>外围方法开启事务时，内部方法仍旧会开启独立的事务，与外部事务相互独立，互不干扰。</strong></p>
<h4 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a>PROPAGATION_NESTED</h4><p>在<strong>外围方法未开启事务</strong>的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。<strong>外围方法没有开启事务，内部方法分别开启自己的事务，相互独立互不干扰。</strong></p>
<p>在<strong>外围方法开启事务</strong>的情况下<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务。<strong>外围方法开启事务时，内部方法的事务为外围方法的子事务，外围事务回滚内部事务同时回滚，但是内部事务可以单独捕获，并且外围事务不回滚。</strong></p>
<h1 id="5、SpringMVC概述"><a href="#5、SpringMVC概述" class="headerlink" title="5、SpringMVC概述"></a>5、SpringMVC概述</h1><h2 id="SpringMVC是什么"><a href="#SpringMVC是什么" class="headerlink" title="SpringMVC是什么"></a>SpringMVC是什么</h2><p>Spring Web MVC是一种基于Java的，实现了Web MVC设计模式的请求驱动类型的<strong>轻量级Web框架</strong>。即，使用了MVC架构的模式的思想，简化开发Web开发。</p>
<p>前端控制器是<code>DispatcherServlet</code>。</p>
<p>应用控制器拆分为处理器映射器<code>HandlerMapping</code>进行处理器管理和视图解析器<code>View Resolver</code>进行视图管理。</p>
<p>页面控制器是<code>Controller接口</code>（仅包含<code>ModelAndView handleRequest(request, response)</code>方法）的实现。</p>
<p>提供了非常灵活的数据验证、格式化和数据绑定机制；提供了强大的配置（约定大于配置）编程支持。</p>
<h2 id="Spring-MVC架构"><a href="#Spring-MVC架构" class="headerlink" title="Spring MVC架构"></a>Spring MVC架构</h2><p>Spring Web MVC框架也是一个基于请求驱动的Web框架，并且也是用了前端控制器模式来进行设计，再根据请求映射规则分发给响应的页面控制器进行处理。</p>
<h3 id="Spring-MVC-处理请求的流程"><a href="#Spring-MVC-处理请求的流程" class="headerlink" title="Spring MVC 处理请求的流程"></a>Spring MVC 处理请求的流程</h3><p><img src="/2021/08/04/back-end/Java/Spring/Spring/image-20210804142503656.png"></p>
<p>图片来自：<a target="_blank" rel="noopener" href="https://github.com/h2pl/Java-Tutoria">https://github.com/h2pl/Java-Tutoria</a></p>
<p>具体执行流程如下：</p>
<ol>
<li>用户发起请求——&gt;前端控制器（DispatcherServlet）接收，并根据请求的信息（如URL）来决定哪个页面控制器进行处理然后把该请求委托给它。</li>
<li>页面控制器（Controller）收到请求后对请求进行具体的功能处理（调用业务层Service对象）；处理完毕后返回一个ModelAndView对象给前端控制器。</li>
<li>前端控制器根据返回的视图名View选择对应的页面进行渲染，并把模型数据一并传入视图供视图进行数据渲染。</li>
<li>最后前端控制器将响应返回给用户。</li>
</ol>
<h3 id="Spring-MVC-架构图"><a href="#Spring-MVC-架构图" class="headerlink" title="Spring MVC 架构图"></a>Spring MVC 架构图</h3><p><img src="/2021/08/04/back-end/Java/Spring/Spring/image-20210804145139577.png"></p>
<p>图片来自：<a target="_blank" rel="noopener" href="https://github.com/h2pl/Java-Tutoria">https://github.com/h2pl/Java-Tutoria</a></p>
<h3 id="Spring-MVC-优势"><a href="#Spring-MVC-优势" class="headerlink" title="Spring MVC 优势"></a>Spring MVC 优势</h3><ol>
<li>清晰的角色划分：前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver）、页面控制器（Controller）、验证器（Validator）等。</li>
<li>分工明确，扩展灵活，很容易扩展。</li>
<li>和其他Spring框架无缝集成，是其他Web框架所不具备的。</li>
<li>可定制性，HandlerMapping、ViewResolver能够很容易定制。</li>
<li>支持RESTful风格。</li>
<li>约定大于配置的契约式编程。</li>
<li>基于注解的零配置支持。</li>
</ol>
<h3 id="DispatcherServlet作用"><a href="#DispatcherServlet作用" class="headerlink" title="DispatcherServlet作用"></a>DispatcherServlet作用</h3><p>DispatcherServlet是前端控制器设计模式的实现，提供Spring Web MVC的集中访问点，负责职责的分派，与Spring IoC容器无缝集成。主要职责如下：</p>
<ol>
<li>文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析。</li>
<li>通过HandlerMapping，将请求映射到处理器。</li>
<li>通过ViewResolver解析逻辑视图名到具体视图实现。</li>
</ol>
<p>DispatcherServlet主要负责流程控制。</p>
<p>本文部分内容参考自：<a target="_blank" rel="noopener" href="https://github.com/h2pl/Java-Tutorial/">https://github.com/h2pl/Java-Tutorial/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fangaoxs.github.io/2021/08/04/back-end/Java/Spring/Spring/" data-id="clto7kdyj002jdnk60ouy1143" data-title="Spring简单剖析" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/08/19/data-structure/%E6%89%8B%E5%86%99ArrayList/ArrayList%E6%95%B4%E5%90%88Java/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          利用Java来手写ArrayList
        
      </div>
    </a>
  
  
    <a href="/2021/06/02/full-stack/WebScoket/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%88%A9%E7%94%A8WebSocket%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">前后端使用利用WebSocket进行通信</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cookie/" rel="tag">Cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GRPC/" rel="tag">GRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OIDC/" rel="tag">OIDC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/devops/" rel="tag">devops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echarts/" rel="tag">echarts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernates/" rel="tag">kubernates</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uni-app/" rel="tag">uni-app</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/" rel="tag">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" rel="tag">网络安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/GRPC/" style="font-size: 13.33px;">GRPC</a> <a href="/tags/Golang/" style="font-size: 18.33px;">Golang</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/OIDC/" style="font-size: 13.33px;">OIDC</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/devops/" style="font-size: 10px;">devops</a> <a href="/tags/docker/" style="font-size: 11.67px;">docker</a> <a href="/tags/echarts/" style="font-size: 10px;">echarts</a> <a href="/tags/http/" style="font-size: 11.67px;">http</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/kubernates/" style="font-size: 10px;">kubernates</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/redis/" style="font-size: 11.67px;">redis</a> <a href="/tags/uni-app/" style="font-size: 10px;">uni-app</a> <a href="/tags/vue/" style="font-size: 16.67px;">vue</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/websocket/" style="font-size: 10px;">websocket</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 11.67px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 11.67px;">数据结构</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="font-size: 11.67px;">网络安全</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 11.67px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/03/12/back-end/go/gmp/">Goroutine调度器GMP</a>
          </li>
        
          <li>
            <a href="/2024/01/31/back-end/docker/dockerfile/">dockerfile</a>
          </li>
        
          <li>
            <a href="/2023/11/07/network/caddy/http%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">利用Caddy实现http反向代理</a>
          </li>
        
          <li>
            <a href="/2023/07/25/network/OIDC/%E7%BB%93%E5%90%88OIDC%E5%92%8CCookie%E5%AE%9E%E7%8E%B0SSO/">结合OIDC和Cookie实现SSO</a>
          </li>
        
          <li>
            <a href="/2023/07/24/back-end/Java/Java%E5%AE%B9%E5%99%A8/%E9%9B%86%E5%90%88/">Java集合</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 FanGaoXS<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>